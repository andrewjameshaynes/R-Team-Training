---
title: "Team Training"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

This is an interactive R notebook which contains all the training materials. When you execute code within the notebook, the results appear beneath the code. 

This workbook is broken down into 6 sections.

0. Introduction to R and Rstudio
1. Data Types, Operators and Basic Operations
2. Data Structures, Manipulations and all things data
3. Conditional Statements and Loops
4. Functions and Packages
5. Plotting, SQL connection and Heathrow Analytics use case
6. Modelling

## 0. Introduction to R and RStudio

R is an interpreted implementation of the statistical programming language S, and has been around since 2000. R comes with it's own default GUI but the overwhelming most popular front-end for R is RStudio which is developed by the R foundation. RStudio offers lots of additional ease of use tools such as autocompletion, plotting interface, package installers and a git interface as well as just generally being clean and lovely to use.

There are a few places in RStudio worth mentioning:

**Console**: This is where you write your code. It will most likely be in the bottom left quadrant but you may put it wherever is most comfortable. To execute code all you have to do is type into the console and press Enter. If saved to a variable then it will appear in the top right under "Enviroment" and can be called from the console.

**Enviroment**: This is where your variables, functions and datasets are stored and viewed. The enviroment window will give you information on the size, type and name of your objects. It also contains the import dataset for when you're too lazy to import files programmatically (or you can't rememeber the correct package for .xlsx files)

**Plots**: This is where yourplotting outputs will be displayed. There is also the ability to zoom in and explore your visualisation (interactively, depending on the package) and then allows you to export the data to a desired location.

**Packages**: These are the currently installed packages on your computer that R can see. RStudio comes with a number of popular packages already pre-installed thatjust need to be imported before using. Your best friend will be the 'Install' button where you can explore CRAN (Comprehensive R Archive Network) for any pre-built, ready to go code published freely.

**Help**: Your new best friend. The CRAN network is one of R's greatest achievements and is an encyclopedic level of documentation, explanation and examples. You can either search through Help itself, or you can type '?' before the name of a function or package you want to know about and it will be displayed int he help window.

A few other tips and tricks:

- Use `setwd()` and `getwd()` to set and get your current working directory.
- You can run code line-by-line in the script sections, or run just highlighted code by using ctrl + enter
- Comments for code are done by placing a '#' at any point on a line. R does not have multiline comments.
- R has two assignment operators '=' and the more traditional '<-' for this training I will use an equals sign as it should be more familiar.


## 1. Data Types, Operators and Basic Operations

# Data types
What other languages called data 'types', R calls data classes. R has lots of classes, but the main ones are:

- Integers, such as 1, 87 and -9
- Numerics, such as 1, 87.8 and -9.0
- Characters, such as 'a', "hello"" and '1'. Characters in R can be defined with both single and double quotes
- Logical: TRUE, FALSE and the aliases T and F


We can define an integer by adding L to our value. We wan then check its type using the `class()` function - try changing the value of and test to see what class returns.

```{r}
x = 1L #also try 1, '1' and T
class(x)
```

R has 2 main types of functions to detect and maipulate these classes which are `is.`, which checks the variable and returns a boolean value, and the `as.` functions which set the class of a value.

```{r}
x = 1L 
is.character(x) #checks to see if it is a string
x=as.character(x) #alters the class 
class(x) # returns the new class of x
print(x) # return the new x
```


# Operators 

R also comes with a whole host of operators.

**Artihmetic Operators:**

Operator | Name
--------- | --------
+ | addition
 - | subtration
 * | multiplication
 / | division
 ^ or ** | exponent
 %% | modulus
 %/% | integer division 

Feel free to play around with these operators in the console, but here are some examples of each:

```{r}
2+3
2-3
2*3
2/3
2^3
2%%3
2%/%3
```
 

**Logical Operators:**

Operator | Name
--------- | --------
< | less than
<= | less than or equal
 > | greater Than
 >= | greater than or equal
 == | exactly equal to
 != | not equal to
 !  | not
 \|  | OR
 &  | AND
 
Feel free to play around with these operators in the console, but here are some examples of each:

```{r}
2<3 #TRUE

2==3 #FALSE
1=='1' #TRUE

T & F # FALSE

(T & T) & (T | F) # TRUE


```


# Coersion

As you saw in the last example, `1` and `'1'` were evaluated to be equal. You will also see the same results if you try `T==1`. This is because R is a dynamically typed language and at runtime will try to coerce everything nice together in the following rough logic:

> logical < integer < numeric < character

Basically logical is the strictest data class only allowing `TRUE` and `FALSE` whereas character is an extremely flexible class and allows other types to be converted to character at runtime if there is a combination of values. This is particularly useful when we look at string manipulation.

# String Operations

R is a statistical programming language. It has beautifully optimised methods for dealings with data, numbers and modelling. Most base R functions are optimised in C or C++ and for small data volumes are not only fast, but also accurate and easy to use. It'll be a shock to you to learn that strings and manipulations of them in R are an **absolute nightmare**.

Let's start with some basics. To define a string in R you can use either double or quotes with no difference between the two.

```{r}
string = 'Hello World!'
print(string)

```

We can then find properties about our new string with functions such as `length()` which returns the number of strings and `nchar()` which returns the number of characters that make up the string. 

```{r}
string = 'Hello World!'
length(string)
nchar(string)

```

There are then a few basic functions (with strange names) that we can use to manipulate strings:

- `paste` which is the conatenation function for R, is used to concat and collapse strings together (also see `?paste0`)
- `strsplit` which allows you to split strings based on a delimeter
- `substr` which find substrings, (also see `?substring()`)
- `gsub` which is a global replace of a character, substring or regex within the string
- `tolower/toupper` which are builtins to capitalise and lowercase a string


Let's start by focusing on paste:

```{r}
string1 = "Hello"
string2 = "World!"
paste(string1, string2, sep = ' ') ## simple concat

paste(string1, string2, 'is a terrible catchphrase', sep = ',')

## also allows non string values, and cross concatenation
paste('string',1:2)

## can also be used to collapse a bunch of letters
split_string = c('H','e','l','l','o')
print(split_string)

paste('What is the output of collapsing split_string? ->', paste(split_string, collapse = ''))

```


We can then look at the opposite of paste, which is substring:

```{r}
## split string for it to make sense
string_to_split = 'Hello &World! &How &are& you& doing?'
strsplit(string_to_split, split = '&')

```



```{r}
#string
```


## 2. Data Structures and manipulation

R has N many types of data structure:

- Vector
- Data frame
- Matrix
- List
- Array

For this training we will focuso the first 4 of these. But it is worth bearing in mind that in R, everything that is an object is fundamentally a list (despite how cleverly hidden)

# Vectors 

Vectors in R are the basic default type for one dimensional data. They are similar to lists in python, arrays in some laguages, and more accurately described as columns in others.

To define a vector we use the `c()` function. `c` stands for concatenate/coerce depending on who you ask. We can then reference individal elements inside a vector with single square brackets - remeber R is 1-indexed!


```{r}
## as a vector of strings
greetings = c("Hello", "Hey", "ahoy")
print(greetings)

## as numeric
numbers = c(1, 5.5, 29)
print(numbers)

## print first element of numbers
print(numbers[1])

## what happens if we combine both?
mixture = c("hello world", 1 , T, "woof")
print(mixture)
```

As we can see from above it is easy to create a vector of bespoke values. What is interesting to note is that vectors also satisfy the coercion laws that we saw earlier and will coerce information into the lowest level of coercion.

At this point it is worth nothing there is a reason that vectors are called vectors and not lists, or even scalars. Objects in R are naturally vectorised. That means that if you apply *simple* functions to a vector R then the operation is applied to all the elements of that vector individually.

For instance, if we multiplty a vector of numbers by 2:

```{r}
## show benefits of vectorisation
numbers = c(1,2,4,6,9,20)
numbers_doubled = numbers * 2

print(numbers)
print(numbers_doubled)
```

Equally importantly is to think of operations as being performed elementwise, for example what happens if I multiply two vectors together?

```{r}
c(1,2,3) * c(1,2,3)
```

# Data Frames

Data frames, also known as Dataframes but known in R as Data.Frames, are the workhorse of R data analyses. They can be considered synonymous with tables in other languages, but with easy indexing and nice layout.

To define a data frame we use the `data.frame()` function. This function requires a number of vectors >1 to be read in with (or without vector names). For example, let's define a data frame with the names of people and their 'australian score':

```{r}
aussie_scores = data.frame( Names = c('Andrew', 'Claire', 'Chris', 'Allen'),
                            Aussie_score = c(1,1,10,1))

print(aussie_scores)
```

You can also pass matrices and other data.frames to `data.frame()`, and combinations of both with vectors to create a dataset.

We can index data.frame's by using square brackets. Data.frames require at least 2 elements select data, `i` referring to the rows, and `j` referring to the columns, separated by a comma - [i,j]

We can also access columns (only one, and not rows) by using the `$` operator. Such as `aussie_scores$Names`.

```{r}
aussie_scores[1,1] ## gives Andrew

aussie_scores[1, ] ## gives entire first row

aussie_scores[ ,1] ## gives first column (as vector)

aussie_scores[ ,1, drop = F]

aussie_scores[1:2, 1:2] ## gives first 2 columns and first 2 rows

aussie_scores$Names ## gives the same as aussie_scores[,1]

```

Data.frames can be easily passed to a number of different functions just as you would a vector. Some regular ones are here:

```{r}
length(iris) ## length - for a dataframe this means the number of columns
nrow(iris)  ## number of rows
ncol(iris)  ## number of columns
dim(iris)  ## the dimensions -  rows, columns
summary(iris)  ## produces values for min, max, mean, median and quartiles if numeric, counts if not
str(iris)  ## structure of the data - gives dimensions, column names, data type and preview of first 10 rows
```


Data.frames are really easy to use and manipulate and comes with all the usual functions such as `merge`, unions - done with `rbind` for data setting, and `cbind` for appending columns without a merge.

```{r}
aussie_scores = data.frame( Names = c('Andrew', 'Claire', 'Chris', 'Allen'),
                            Aussie_score = c(1,1,10,1))
                            
drink_of_choice = data.frame( Names = c('Andrew', 'Claire', 'Chris'),
                              Drinks = c('Mojito', 'Tequila Sunrise', 'Espresso Martini'))

merge(aussie_scores, drink_of_choice, by = "Names") ## inner join
merge(aussie_scores, drink_of_choice, by = "Names", all.x = TRUE) ## left join

iris_top = head(iris, 6)
iris_bottom = tail(iris, 6)

cbind(iris_top, iris_bottom) ## append the two data sets next to each other
rbind(iris_top, iris_bottom) ## set data on top of each other
```


# 3. Conditional Statements and loops

## Conditional Statements

R has multiple ways of running if-else statements, they are primarily `if()`, `ifelse()` and `switch()`. Switch statements are rarely used in R, and the preferred method is to use nested if-else or ifelse statements. The syntax for if statements is as below:

```{r}
## if-else statement
if(condition1){
  
} else if(condition2){
  
} else {
  
}

## ifelse statement

ifelse(condition, value_if_true, value_if_false)

```

if-else and ifelse() statements have two different purposes. if-else statements are used for **control flow**, similar to other languages. ifelse() statements are more often used to select and create elements of a data object.

For example, we could use either method to print a single value based on a condition, or assign a new value to a variable:

```{r}
## print values
if(1 > 0){
  print('success!')
} else {
  print('not a success!')
}

ifelse(1 > 0, 'success!', 'not a success!')

## assign values to a variable


if(TRUE != FALSE){
  a = 17
}
print(a)

b = ifelse(TRUE > FALSE, 12, 0)
print(b)
```

The advantage of `ifelse()` other than its smaller syntax is that it is naturally vectorised, and makes it extremely useful for editing and selecting values from a vector (and by extension dataframes and lists).

```{r}
## replace all occurences of staff 0/1 flag with nice labels

# create dataframe
df = data.frame(Staff = c(0,1,0,1), Class = c('A', 'A', 'B', 'B'), Spend = c(1,4,2,8))
print(df)

##create new vector of values
ifelse(df$Staff == 1, 'Staff', 'Passenger')

## apply to dataframe
df$Staff = ifelse(df$Staff == 1, 'Staff', 'Passenger')
print(df)
```


## Loops
